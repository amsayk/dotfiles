" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

" Initialize vim-plug and specify the path
" where the plugins should be installed.

" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

call plug#begin('~/.vim/plugged')
  Plug 'vim-scripts/gitignore'

  Plug 'tpope/vim-unimpaired'

  Plug 'jparise/vim-graphql', { 'for': [ 'graphql' ] }

  Plug 'haya14busa/incsearch.vim'

  Plug 'kana/vim-textobj-user'
  Plug 'kana/vim-textobj-entire' " ae, ie
  Plug 'kana/vim-textobj-indent' " ai, ii
  Plug 'kana/vim-textobj-line'   " al, il
  Plug 'glts/vim-textobj-comment' " ac, ic
  Plug 'kana/vim-textobj-function' " af, if
  Plug 'mattn/vim-textobj-url' " au, iu
  Plug 'saihoooooooo/vim-textobj-space' " aS, iS

  Plug 'thinca/vim-textobj-function-javascript'

  Plug 'pangloss/vim-javascript', { 'for': [ 'javascript', 'javascript.jsx' ] } | Plug 'mxw/vim-jsx', { 'for': [ 'javascript', 'javascript.jsx' ] }
  Plug 'elzr/vim-json', { 'for': [ 'json' ] }
  " Plug 'flazz/vim-colorschemes'
  Plug 'matchit.zip'

  " Ag/Ack for project-wide searching
  Plug 'mileszs/ack.vim', { 'on': [ 'Ack' ] }

  " Plug 'editorconfig/editorconfig-vim'
  Plug 'ctrlpvim/ctrlp.vim'

  Plug 'JulesWang/css.vim'
  Plug 'ap/vim-css-color'
  Plug 'tpope/vim-haml', { 'for': [ 'haml', 'scss', 'sass' ] }
  Plug 'mattn/emmet-vim', { 'for': [ 'html', 'css', 'javascript', 'javascript.jsx' ] }

  Plug 'mattn/webapi-vim'
  Plug 'othree/html5.vim'
  Plug 'plasticboy/vim-markdown', { 'for': [ 'markdown' ] }
  Plug 'raimondi/delimitmate'
  Plug 'airblade/vim-gitgutter'
  " Plug  'neomake/neomake'
  Plug 'SirVer/ultisnips' | Plug 'epilande/vim-es2015-snippets' | Plug 'epilande/vim-react-snippets'
  Plug 'tomtom/tcomment_vim'
  Plug 'tpope/vim-fugitive'
  Plug 'tpope/vim-repeat'
  Plug 'tpope/vim-surround'
  Plug 'kshenoy/vim-signature'    "show marks

  Plug 'vim-airline/vim-airline' | Plug 'vim-airline/vim-airline-themes'

  if has('nvim')
    Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
  endif

  Plug 'duggiefresh/vim-easydir'

  Plug 'wakatime/vim-wakatime'

  Plug 'tommcdo/vim-lion' " Align: gl, gL

  Plug 'derekwyatt/vim-scala', { 'for': [ 'scala' ] }

  Plug 'elmcast/elm-vim', { 'for': [ 'elm' ] }

  Plug 'scrooloose/nerdtree'
  Plug 'Xuyuanp/nerdtree-git-plugin' | Plug 'tiagofumo/vim-nerdtree-syntax-highlight'
  Plug 'ryanoasis/vim-webdevicons'

  Plug 'chriskempson/base16-vim'

  Plug  'pearofducks/ansible-vim', { 'for': [ 'yaml', 'ansible' ] }

  Plug 'tpope/vim-abolish'

  Plug 'mhinz/vim-startify'

  Plug 'mbbill/undotree'
  Plug 'tpope/vim-eunuch'

  Plug 'AndrewRadev/splitjoin.vim'

  Plug 'tmux-plugins/vim-tmux-focus-events'
  Plug 'tmux-plugins/vim-tmux', { 'for': [  'tmux' ] }

  Plug 'ekalinin/Dockerfile.vim', { 'for' : 'Dockerfile' }
  Plug 'fatih/vim-nginx' , { 'for' : 'nginx' }

  Plug 'skywind3000/asyncrun.vim'

  Plug 'justinmk/vim-sneak'

  Plug 'matze/vim-move' " <c-k>, <c-j>
  Plug 'joeytwiddle/sexy_scroller.vim'

  Plug 'wincent/vim-clipper'

  if has('nvim')
    Plug 'kassio/neoterm'
  endif

  Plug 'terryma/vim-expand-region'
  Plug 'vim-scripts/ReplaceWithRegister' "replace <motion> with register

  Plug 'leafgarland/typescript-vim', { 'for': [ 'typescript' ] }
  Plug 'Quramy/vim-js-pretty-template', { 'for': [ 'javascript', 'javascript.jsx' ] }

  " Plug 'flowtype/vim-flow', { 'for': [ 'javascript', 'javascript.jsx' ] }

  Plug 'brooth/far.vim', { 'do': ':UpdateRemotePlugins', 'branch': 'dev' }

  Plug 'rust-lang/rust.vim', { 'for': [ 'rust' ] }

  Plug 'kewah/vim-stylefmt', { 'for': [ 'sass', 'scss', 'css' ] }

  Plug 'christoomey/vim-sort-motion'
call plug#end()

" ----------------------------------------------------------------------
" | General Settings                                                   |
" ----------------------------------------------------------------------

" Use a different mapleader (default is '\').

let mapleader="\<Space>"
let maplocalleader=mapleader

if exists("$TMUX")
  " Disable CTRL-Space on tmux or on screen
  nnoremap <C-Space> <NOP>
  nnoremap <leader><C-Space> <C-Space>
endif

set termencoding=utf-8
scriptencoding utf-8

if has('termguicolors')
  set termguicolors
endif

" Live substitution
if has('nvim')
  set inccommand=split
endif

" Vim usable (these are default on NeoVim)
if !has('nvim')
  set nocompatible
  filetype off

  if has('autocmd')
    filetype plugin indent on
    "           │     │    └──── Enable file type detection.
    "           │     └───────── Enable loading of indent file.
    "           └─────────────── Enable loading of plugin files.
  endif

  set ttyfast
  set ttyscroll=3

  set laststatus=2

  if has('vim_starting')
    set encoding=utf-8 nobomb              " Set default encoding to UTF-8
  endif

  set autoindent
  set backspace=indent,eol,start  " Makes backspace key more powerful.
  set incsearch                   " Shows the match while typing
  set hlsearch                    " Highlight found searches
  set mouse=a
  if has('mouse_sgr')
    set ttymouse=sgr
  else
    set ttymouse=xterm2
  endif
endif

if exists('$SUDO_USER')
  set nobackup                        " don't create root-owned files
  set nowritebackup                   " don't create root-owned files
else
  set backupdir=~/.vim/tmp/backup   " Set directory for backup files.
endif

set backupskip=/tmp/*               " ┐ Don't create backups
set backupskip+=/private/tmp/*      " ┘ for certain files.

if exists('&belloff')
  set belloff=all                     " never ring the bell for any reason
endif

if (executable('pbcopy') || executable('xclip') || executable('xsel')) && has('clipboard') && exists('$DISPLAY')
  set clipboard=unnamed,unnamedplus     "  Use the system clipboard as the default register.
endif

set cpoptions+=$               " When making a change, don't
                               " redisplay the line, and instead,
                               " put a `$` sign at the end of
                               " the changed text.

if exists('+colorcolumn')
  " Highlight at textwidth and from 80 + 40 columns (this is the current Vim max) beyond 'textwidth'
  let &l:colorcolumn="80," . join(map(range(40,999), '"+" . v:val'), ',')
endif

set cursorline                 " Highlight the current line.
set cursorcolumn               " Highlight the current column.

if exists('$SUDO_USER')
  set noswapfile                      " don't create root-owned files
else
  set directory=~/.vim/tmp/swap//  " Set directory for swap files.
endif

set history=5000               " Increase command line history.
set ignorecase                 " Ignore case in search patterns.

set incsearch                  " Highlight search pattern
                               " as it is being typed.


set lazyredraw                 " Do not redraw the screen while
                               " executing macros, registers
                               " and other commands that have
                               " not been typed.

if !has('nvim')
  syntax enable
  let &t_Co = 256
  set term=ansi

  " Make arrow keys work in vim
  imap <ESC>oA <ESC>ki
  imap <ESC>oB <ESC>ji
  imap <ESC>oC <ESC>li
  imap <ESC>oD <ESC>hi
endif

if has('gui_macvim')
  " No toolbars, menu or scrollbars in the GUI
  set guifont=Sauce\ Code\ Pro\ Nerd\ Font\ Complete:h12
  set clipboard+=unnamed
  set vb t_vb=
  set guioptions-=m  "no menu
  set guioptions-=T  "no toolbar
  set guioptions-=l
  set guioptions-=L
  set guioptions-=r  "no scrollbar
  set guioptions-=R
endif

if has('linebreak')
  set breakindent                     " indent wrapped lines to match start
  if exists('&breakindentopt')
    set breakindentopt=shift:2        " emphasize broken lines by indenting them
  endif
endif

set magic                      " Enable extended regexp.
set mousehide                  " Hide mouse pointer while typing.
set noerrorbells               " Disable error bells.

set nojoinspaces               " When using the join command,
                               " only insert a single space
                               " after a `.`, `?`, or `!`.

set nostartofline              " Kept the cursor on the same column.
set number                     " Show line number.

if exists('+relativenumber')
  set relativenumber                  " show relative numbers in gutter
endif

set numberwidth=4              " Increase the minimal number of
                               " columns used for the `line number`.

set report=0                   " Report the number of lines changed.
set ruler                      " Show cursor position.

set scrolloff=1                " When scrolling, keep the cursor
                               " 5 lines below the top and 5 lines
                               " above the bottom of the screen.

set sidescrolloff=5            " same as scolloff, but for columns

set display+=lastline

if has('linebreak')
  let &showbreak='⤷ '          " ARROW POINTING DOWNWARDS THEN CURVING RIGHTWARDS (U+2937, UTF-8: E2 A4 B7)
endif

" Avoid all the hit-enter prompts.
set shortmess+=A                 " ignore annoying swapfile messages
set shortmess+=I                 " no splash screen
set shortmess+=O                 " file-read message overwrites previous
set shortmess+=T                 " truncate non-file messages in middle
set shortmess+=W                 " don't echo "[w]"/"[written]" when writing
set shortmess+=a                 " use abbreviations in messages eg. `[RO]` instead of `[readonly]`
set shortmess+=o                 " overwrite file-written messages
set shortmess+=t                 " truncate file messages at start

if has('showcmd')
  set showcmd                    " Show the command being typed.
endif

set showmode                   " Show current mode.
set spelllang=en_us            " Set the spellchecking language.

set smartcase                  " Override `ignorecase` option
                               " if the search pattern contains
                               " uppercase characters.

set synmaxcol=2500             " Limit syntax highlighting (this
                               " avoids the very slow redrawing
                               " when files contain long lines).

set tabstop=2                  " ┐
set shiftround                 " │ Set global <TAB> settings.
set shiftwidth=2               " │
set expandtab                  " ┘

if v:progname !=# 'vi'
  set softtabstop=-1           " use 'shiftwidth' for tab/bs at end of line
endif

if has('persistent_undo')
  if exists('$SUDO_USER')
    set noundofile                    " don't create root-owned files
  else
    set undodir+=~/.vim/tmp/undo      " keep undo files out of the way
    set undofile                      " actually use undo files
  endif
endif

set visualbell                 " ┐
set noerrorbells               " │ Disable beeping and window flashing
set t_vb=                      " ┘ https://vim.wikia.com/wiki/Disable_beeping


set wildmenu                   " Enable enhanced command-line
                               " completion (by hitting <TAB> in
                               " command mode, Vim will show the
                               " possible matches just above the
                               " command line with the first
                               " match highlighted).

set wildmode=longest:full,full        " shell-like autocomplete to unambiguous portion

set wildcharm=<C-z>            " substitue for 'wildchar' (<Tab>) in macros

set wildignore+=*/.git/*,*/tmp/*,*.swp " Ignore files

set winminheight=0             " Allow windows to be squashed.

if has('folding')
  if has('windows')
    " set fillchars=vert:┃              " BOX DRAWINGS HEAVY VERTICAL (U+2503, UTF-8: E2 94 83)
  endif
  set foldmethod=indent               " not as cool as syntax, but faster
  set foldlevelstart=99               " start unfolded
endif

set pumheight=10             " Completion window max size

if v:version > 703 || v:version == 703 && has('patch541')
  set formatoptions+=j                " remove comment leader when joining comment lines
endif

set formatoptions+=n                  " smart auto-indenting inside numbered lists

" indentation
set formatoptions+=w
set smartindent

if has('linebreak')
  set linebreak                       " wrap long lines at characters in 'breakat'
endif

" ----------------------------------------------------------------------
" | Plugins - Emmet                                                    |
" ----------------------------------------------------------------------

" Redefine trigger key for Emmet.
" http://docs.emmet.io/cheat-sheet/

" let g:user_emmet_leader_key="<C-E>"

let g:user_emmet_install_global = 0
autocmd FileType html,css,javascript,javascript.jsx EmmetInstall

" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

" Load custom Emmet snippets.
" http://docs.emmet.io/customization/snippets/

let g:user_emmet_settings = webapi#json#decode(join(readfile(expand("~/.vim/snippets/emmet.json")), "\n"))

" ----------------------------------------------------------------------
" | Plugins - Markdown                                                 |
" ----------------------------------------------------------------------

" Disable Folding.
" https://github.com/plasticboy/vim-markdown#disable-folding

let g:vim_markdown_folding_disabled=1

" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

function! s:StripTrailingWhitespaces()

    " Save last search and cursor position.

    let searchHistory = @/
    let cursorLine = line(".")
    let cursorColumn = col(".")

    " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    " Strip trailing whitespaces.

    %s/\s\+$//e

    " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    " Restore previous search history and cursor position.

    let @/ = searchHistory
    call cursor(cursorLine, cursorColumn)

endfunction

nnoremap <c-c>w :call <SID>StripTrailingWhitespaces()<CR>

" ----------------------------------------------------------------------
" | Automatic Commands                                                 |
" ----------------------------------------------------------------------

if has('autocmd')

  " Autocommand Groups.
  " http://learnvimscriptthehardway.stevelosh.com/chapters/14.html

  " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  " Automatically strip the trailing
  " whitespaces when files are saved.

  augroup strip_trailing_whitespaces

    " List of file types that use the trailing whitespaces:
    "
    "  * Markdown
    "    https://daringfireball.net/projects/markdown/syntax#block

    let excludedFileTypes = [
          \ "markdown",
          \ "mkd.markdown"
          \]

    " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    " Only strip the trailing whitespaces if
    " the file type is not in the excluded list.

    autocmd!
    autocmd BufWritePre * if index(excludedFileTypes, &ft) < 0 | :call s:StripTrailingWhitespaces()

  augroup END

endif

" Search and replace the word under the cursor.

" Replace all

nnoremap <leader>r :%s/\V\<<C-r>=functions#escape_pattern(expand('<cword>'))<CR>\>//gc<Left><Left><Left>
vnoremap <leader>r :<c-u>%s/\V<c-r>=functions#escape_pattern(functions#get_visual_selection())<CR>//gc<Left><Left><Left>

" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

" Toggle NERDTree.

nnoremap <leader>n :NERDTreeToggle<CR>

nnoremap <leader>m :NERDTreeFind<CR>

" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

" Make the opening of the `.vimrc` file easier.

nnoremap <c-s>e :e $MYVIMRC<CR>
nnoremap <c-s>r :source $MYVIMRC<CR>

" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

set hidden

" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

set highlight+=@:ColorColumn          " ~/@ at end of window, 'showbreak'
set highlight+=N:DiffText             " make current line number stand out a little
set highlight+=c:LineNr               " blend vertical separators with line numbers

" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

" Don't continue comment mark after press 'o' when you're on a commented line.
autocmd FileType * setlocal formatoptions-=c formatoptions-=r formatoptions-=o

" Don't automatically break lines at textwidth
autocmd FileType * setlocal formatoptions-=t

" <Ctrl-l> redraws the screen and removes any search highlighting.
nnoremap <silent> <C-L> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR><C-L>

" toggle invisible characters
set list
set listchars=nbsp:⦸                  " CIRCLED REVERSE SOLIDUS (U+29B8, UTF-8: E2 A6 B8)
set listchars+=tab:▷┅                 " WHITE RIGHT-POINTING TRIANGLE (U+25B7, UTF-8: E2 96 B7)
                                      " + BOX DRAWINGS HEAVY TRIPLE DASH HORIZONTAL (U+2505, UTF-8: E2 94 85)
set listchars+=extends:»              " RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK (U+00BB, UTF-8: C2 BB)
set listchars+=precedes:«             " LEFT-POINTING DOUBLE ANGLE QUOTATION MARK (U+00AB, UTF-8: C2 AB)
set listchars+=trail:•                " BULLET (U+2022, UTF-8: E2 80 A2)

set completeopt-=preview    " Don't show preview window during completion.
set complete-=i

set smarttab                " tab respects 'tabstop', 'shiftwidth', and 'softtabstop

set textwidth=80               " automatically hard wrap at 80 columns

" Airline

let g:airline_powerline_fonts = 1

if !exists('g:airline_symbols')
  let g:airline_symbols = {}
endif
let g:airline_symbols.space = "\ua0"

let g:airline#extensions#whitespace#enabled = 1

let g:airline_symbols.maxlinenr = ''

let g:airline_symbols.linenr = 'ℓ'

let g:airline_skip_empty_sections = 1

if has('nvim')
  " Use deoplete.
  let g:deoplete#enable_at_startup = 1
  let g:deoplete#enable_smart_case = 1
  let g:deoplete#auto_complete_start_length = 3

  if !exists('g:deoplete#omni#input_patterns')
    let g:deoplete#omni#input_patterns = {}
  endif

  if !exists('g:deoplete#sources')
    let g:deoplete#sources = {}
  endif

  " Scala
  let g:deoplete#sources.scala = ['buffer', 'tags', 'omni']
  let g:deoplete#omni#input_patterns.scala = ['[^. *\t0-9]\.\w*',': [A-Z]\w', '[\[\t\( ][A-Za-z]\w*']
endif

set showtabline=0

" Neomake

" let g:neomake_verbose = 0
" let g:neomake_error_sign = {'text': '❌', 'texthl': 'NeomakeErrorSign'}
" let g:neomake_warning_sign = {'text': '❌', 'texthl': 'NeomakeWarningSign'}
" let g:neomake_place_signs = 0
"
" function! Lint()
"   if &filetype =~ 'javascript'
"     Neomake eslint
"   else
"     Neomake
"   end
" endfunction
"
" augroup lint_events
"   autocmd!
"   autocmd BufWritePost,BufEnter,FocusLost * call Lint()
" augroup end

" For conceal markers.
if has('conceal')
  set conceallevel=1
endif

" VIM jsx

" Conceal some characters in javascript

let g:javascript_conceal_function       = "ƒ"
let g:javascript_conceal_null           = "ø"
let g:javascript_conceal_this           = "@"
" let g:javascript_conceal_return         = "⇚"
let g:javascript_conceal_undefined      = "¿"
let g:javascript_conceal_NaN            = "ℕ"
" let g:javascript_conceal_prototype      = "¶"
" let g:javascript_conceal_static         = "•"
" let g:javascript_conceal_super          = "Ω"
let g:javascript_conceal_arrow_function = "⇒"

let g:jsx_ext_required = 0
let g:javascript_plugin_flow = 1

function! s:SetColorScheme()
  if !has('termguicolors')
    let g:base16colorspace=256
  endif

  let s:config_file = expand('~/.base16')

  if filereadable(s:config_file)
    let s:config = readfile(s:config_file, '', 2)

    if s:config[1] =~# '^dark\|light$'
      execute 'set background=' . s:config[1]
    else
      echoerr 'Bad background ' . s:config[1] . ' in ' . s:config_file
    endif

    if filereadable(expand('~/.vim/plugged/base16-vim/colors/base16-' . s:config[0] . '.vim'))
      execute 'colorscheme base16-' . s:config[0]
    elseif filereadable(expand('~/.vim/plugged/base16-vim/colors/base16-' . s:config[0] . '-' . s:config[1] . '.vim'))
      execute 'colorscheme base16-' . s:config[0] . '-' . s:config[1]
    else
      echoerr 'Bad scheme ' . s:config[0] . ' in ' . s:config_file
    endif
  else " default
    set background=dark
    colorscheme base16-ocean
  endif

  " make the highlighting of tabs and other non-text less annoying
  " highlight SpecialKey ctermbg=none ctermfg=8
  " highlight NonText ctermfg=8 ctermbg=none

  highlight link EndOfBuffer ColorColumn

  " make comments and HTML attributes italic
  highlight Comment cterm=italic  gui=italic
  highlight htmlArg cterm=italic  gui=italic

  let &t_ZH="^[[3m"
  let &t_ZR="^[[23m"

  " Allow for overrides:
  " - `statusline.vim` will re-set User1, User2 etc.
  " - `after/plugin/loupe.vim` will override Search.
  " doautocmd ColorScheme
endfunction

if v:progname !=# 'vi'
  " if has('autocmd')
  "   augroup AmsaykAutocolor
  "     autocmd!
  "     autocmd FocusGained * call s:CheckColorScheme()
  "   augroup END
  " endif

  call s:SetColorScheme()
endif

" Make arrows and some other keys work inside TMUX
if exists('$TMUX')
  execute "set <xUp>=\e[1;*A"
  execute "set <xDown>=\e[1;*B"
  execute "set <xRight>=\e[1;*C"
  execute "set <xLeft>=\e[1;*D"
  execute "set <xHome>=\e[1;*H"
  execute "set <xEnd>=\e[1;*F"
  execute "set <Insert>=\e[2;*~"
  execute "set <Delete>=\e[3;*~"
  execute "set <PageUp>=\e[5;*~"
  execute "set <PageDown>=\e[6;*~"
  execute "set <xF1>=\e[1;*P"
  execute "set <xF2>=\e[1;*Q"
  execute "set <xF3>=\e[1;*R"
  execute "set <xF4>=\e[1;*S"
  execute "set <F5>=\e[15;*~"
  execute "set <F6>=\e[17;*~"
  execute "set <F7>=\e[18;*~"
  execute "set <F8>=\e[19;*~"
  execute "set <F9>=\e[20;*~"
  execute "set <F10>=\e[21;*~"
  execute "set <F11>=\e[23;*~"
  execute "set <F12>=\e[24;*~"
endif

" ----------------------------------------------------------------------------
" Readline-style key bindings in command-line (excerpt from rsi.vim)
" ----------------------------------------------------------------------------
cnoremap        <C-A> <Home>
cnoremap        <C-B> <Left>
cnoremap <expr> <C-D> getcmdpos()>strlen(getcmdline())?"\<Lt>C-D>":"\<Lt>Del>"
cnoremap <expr> <C-F> getcmdpos()>strlen(getcmdline())?&cedit:"\<Lt>Right>"

" Align current paragraph
noremap <leader>a =i{

" Elm

let g:elm_jump_to_error = 1
let g:elm_make_output_file = 'elm.js'
let g:elm_make_show_warnings = 0
let g:elm_syntastic_show_warnings = 0
let g:elm_browser_command = ""
let g:elm_detailed_complete = 0
let g:elm_format_autosave = 1
let g:elm_format_fail_silently = 0
let g:elm_setup_keybindings = 0

" Tags

" Let Vim walk up directory hierarchy from CWD to root looking for tags file
set tags=./.tags;,~/.vimtags

let g:AmsaykColorColumnBlacklist = ['diff', 'undotree', 'nerdtree', 'ctrlp', 'qf']
let g:AmsaykCursorlineBlacklist = ['ctrlp']
let g:AmsaykMkviewFiletypeBlacklist = ['diff', 'gitcommit']

augroup AmsaykAutocmds
  autocmd!

  " Disable paste mode on leaving insert mode.
  autocmd InsertLeave * set nopaste

  function! s:should_colorcolumn() abort
    return index(g:AmsaykColorColumnBlacklist, &filetype) == -1
  endfunction

  function! s:should_cursorline() abort
    return index(g:AmsaykCursorlineBlacklist, &filetype) == -1
  endfunction

  " Loosely based on: http://vim.wikia.com/wiki/Make_views_automatic
  function! s:should_mkview() abort
    return
          \ &buftype == '' &&
          \ index(g:AmsaykMkviewFiletypeBlacklist, &filetype) == -1 &&
          \ !exists('$SUDO_USER') " Don't create root-owned files.
  endfunction

  function! s:mkview() abort
    if exists('*haslocaldir') && haslocaldir()
      " We never want to save an :lcd command, so hack around it...
      cd -
      mkview
      lcd -
    else
      mkview
    endif
  endfunction

  autocmd VimResized * execute "normal! \<c-w>="

  " http://vim.wikia.com/wiki/Detect_window_creation_with_WinEnter
  autocmd VimEnter * autocmd WinEnter * let w:created=1
  autocmd VimEnter * let w:created=1

  " Make current window more obvious by turning off/adjusting some features in non-current
  " windows.
  if exists('+colorcolumn')
    autocmd BufEnter,FocusGained,VimEnter,WinEnter * if s:should_colorcolumn() | let &l:colorcolumn='80,'.join(map(range(40,999), '"+" . v:val'), ',') | endif
    autocmd FocusLost,WinLeave * if s:should_colorcolumn() | let &l:colorcolumn=join(range(1, 999), ',') | endif
  endif

  autocmd InsertLeave,VimEnter,WinEnter * if s:should_cursorline() | setlocal cursorline | endif
  autocmd InsertEnter,WinLeave * if s:should_cursorline() | setlocal nocursorline | endif

  if has('mksession')
    " Save/restore folds and cursor position.
    autocmd BufWritePost,BufWinLeave,BufLeave,WinLeave ?* if s:should_mkview() | call s:mkview() | endif
    if has('folding')
      autocmd BufWinEnter ?* if s:should_mkview() | silent! loadview | execute 'silent! ' . line('.') . 'foldopen!' | endif
    else
      autocmd BufWinEnter ?* if s:should_mkview() | silent! loadview | endif
    endif
  elseif has('folding')
    " Like the autocmd described in `:h last-position-jump` but we add `:foldopen!`.
    autocmd BufWinEnter * if line("'\"") > 1 && line("'\"") <= line('$') | execute "normal! g`\"" | execute 'silent! ' . line("'\"") . 'foldopen!' | endif
  else
    autocmd BufWinEnter * if line("'\"") > 1 && line("'\"") <= line('$') | execute "normal! g`\"" | endif
  endif

  autocmd BufWritePost */spell/*.add silent! :mkspell! %

  " Close preview window
  if exists('##CompleteDone')
    au CompleteDone * pclose
  else
    au InsertLeave * if !pumvisible() && (!exists('*getcmdwintype') || empty(getcmdwintype())) | pclose | endif
  endif
augroup end


" `<Tab>`/`<S-Tab>` to move between matches without leaving incremental search.
" Note dependency on `'wildcharm'` being set to `<C-z>` in order for this to
" work.
cnoremap <expr> <Tab> getcmdtype() == '/' \|\| getcmdtype() == '?' ? '<CR>/<C-r>/' : '<C-z>'
cnoremap <expr> <S-Tab> getcmdtype() == '/' \|\| getcmdtype() == '?' ? '<CR>?<C-r>/' : '<S-Tab>'

" Neovim enhancements

let $NVIM_TUI_ENABLE_CURSOR_SHAPE=1

" Store relative line number jumps in the jumplist if they exceed a threshold.
nnoremap <expr> k (v:count > 5 ? "m'" . v:count : '') . 'k'
nnoremap <expr> j (v:count > 5 ? "m'" . v:count : '') . 'j'

" Make the jk behave

nnoremap j gj
nnoremap k gk

nnoremap ; :
vnoremap ; :

" Relying on Hammerspoon to avoid collision between <Tab> and <C-i> (have it
" send F6 instead for <C-i>).
nnoremap <F6> <C-i>

" Avoid unintentional switches to Ex mode. This would be more useful.
nnoremap Q :normal n.<CR>

" Like vim-vinegar.
nnoremap <silent> - :silent edit <C-R>=empty(expand('%')) ? '.' : fnameescape(expand('%:p:h'))<CR><CR>

nnoremap Y y$

vnoremap y myy`y
vnoremap Y myY`y

" Backspace should delete selection and put me in insert mode

vnoremap <BS> "_xi

" autocmd FocusLost * silent! wa " write all on lost focus
" autocmd TabLeave * silent! wa " autowriteall doesn't capture tab changing

" gf

set suffixesadd+=.js

if isdirectory(expand($PWD.'/node_modules'))
  set path+=$PWD/node_modules
endif

if isdirectory(expand($PWD.'/js'))
  set path+=$PWD/js
endif

set shell=/bin/sh

set updatetime=250

" ==================== delimitMate ====================
let g:delimitMate_expand_cr = 1
let g:delimitMate_expand_space = 1
let g:delimitMate_smart_quotes = 1
let g:delimitMate_expand_inside_quotes = 0
let g:delimitMate_smart_matchpairs = '^\%(\w\|\$\)'

augroup DelimitMate
  autocmd!
  au FileType vim,html,javascript.jsx let b:delimitMate_matchpairs = "(:),[:],{:},<:>"
augroup END

set switchbuf=usetab

set whichwrap=b,h,l,s,<,>,[,],~     " Allow <BS>/h/l/<Right>/<Space> to move cross line boundaries

if has('windows')
  set splitbelow                      " open horizontal splits below current window
endif

if has('vertsplit')
  set splitright                      " open vertical splits to the right of the current window
endif

if has('viminfo')
  if exists('$SUDO_USER')
    set viminfo=                      " don't create root-owned files
  else
    if isdirectory(expand('~/.vim/tmp/info'))
      set viminfo+=n~/.vim/tmp/info/viminfo
    endif

  endif
endif

if has('mksession')
  if isdirectory(expand('~/.vim/tmp'))
    set viewdir=~/.vim/tmp/view
  endif
  set viewoptions=cursor,folds        " save/restore just these (with `:{mk,load}view`)
  set sessionoptions=folds
endif

" <Leader><Leader> -- Open last buffer.
nnoremap <leader><leader> <C-^>

nnoremap <leader>o :only<CR>

" <LocalLeader>c -- Fix (most) syntax highlighting problems in current buffer
" (mnemonic: coloring).
nnoremap <silent> <localleader>c :syntax sync fromstart<CR>

syntax sync minlines=256 " start highlighting from 256 lines backwards
set synmaxcol=300        " do not highlith very long lines
set re=1                 " use explicit old regexpengine, seems to be more faster

" Time out on key codes but not mappings.
" Basically this makes terminal Vim work sanely.
if !has('gui_running')
  set notimeout
  set ttimeout
  set ttimeoutlen=10
  augroup FastEscape
    autocmd!
    au InsertEnter * set timeoutlen=0
    au InsertLeave * set timeoutlen=1000
  augroup END
endif

" Prevent tcomment from making a zillion mappings (we just want the operator).
let g:tcommentMapLeader1=''
let g:tcommentMapLeader2=''
let g:tcommentMapLeaderCommentAnyway=''
let g:tcommentTextObjectInlineComment=''

" The default (g<) is a bit awkward to type.
let g:tcommentMapLeaderUncommentAnyway='gu'

" Count occurences of word under cursor
nnoremap <leader>* *<C-O>:%s///gn<CR>

"" Git
"no mappings by gitgutter
let g:gitgutter_map_keys = 0

"focus window of last created buffer
function! JumpLastBufferWindow()
  call win_gotoid(win_getid(bufwinnr(last_buffer_nr())))
endfunction

nnoremap <c-g>b :Gblame<cr>
nnoremap <c-g>B :Gbrowse<cr>
nnoremap <c-g>s :Gstatus<cr>
nnoremap <c-g>c :Gcommit<cr>
nnoremap <c-g>d :Gvdiff<cr>
nnoremap <c-g>P :Gpush<cr>
nnoremap <c-g>L :Gpull<cr>
nnoremap <c-g>R :!git checkout <c-r>%<cr><cr>
nnoremap <c-g>p :GitGutterPreviewHunk<cr>:call JumpLastBufferWindow()<cr>
nnoremap <c-g>r :GitGutterUndoHunk<cr>
nnoremap <c-g>S :GitGutterStageHunk<cr>
nnoremap <c-g>l :GitGutterLineHighlightsToggle<cr>
nnoremap [h :GitGutterPrevHunk<cr>
nnoremap ]h :GitGutterNextHunk<cr>

let g:gitgutter_sign_added = '↪'
let g:gitgutter_sign_removed = '↩'
let g:gitgutter_sign_modified = '↬'
let g:gitgutter_sign_modified_removed = '↫'

if has('virtualedit')
  set virtualedit=block            " Allow cursor to be anywhere.
endif

" Make vaa select the entire file...
vmap aa VGo1G

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
if !exists(':DiffOrig')
  command DiffOrig vert new | set buftype=nofile | read ++edit # | 0d_ | diffthis
        \ | wincmd p | diffthis
endif

command! -bang -nargs=* -complete=file Make AsyncRun -program=make @ <args>

" Arrow keys madness: Are you ready?

nnoremap <up>    <nop>
nnoremap <down>  <nop>
nnoremap <left>  <nop>
nnoremap <right> <nop>
inoremap <up>    <nop>
inoremap <down>  <nop>
inoremap <left>  <nop>
inoremap <right> <nop>

" Resize split easily
augroup ArrowKeys
  autocmd!

  function! s:ToggleArrowKeys() abort
    nnoremap <silent> <c-up>    :exe "resize " . (winheight(0) * 3/2)<CR>
    nnoremap <silent> <c-down>  :exe "resize " . (winheight(0) * 2/3)<CR>

    nnoremap <silent> <c-right> :exe "vertical resize +5"<CR>
    nnoremap <silent> <c-left>  :exe "vertical resize -5"<CR>

    inoremap <silent> <c-up>    <c-o>:exe "resize " . (winheight(0) * 3/2)<CR>
    inoremap <silent> <c-down>  <c-o>:exe "resize " . (winheight(0) * 2/3)<CR>

    inoremap <silent> <c-right> <c-o>:exe "vertical resize +5"<CR>
    inoremap <silent> <c-left>  <c-o>:exe "vertical resize -5"<CR>
  endfunction

  autocmd BufWinEnter,WinEnter,BufLeave * call s:ToggleArrowKeys()
augroup end

set pastetoggle=

vnoremap . :norm.<CR>

" vim-sneak

"replace 'f' with 1-char Sneak
nmap f <Plug>Sneak_f
nmap F <Plug>Sneak_F
xmap f <Plug>Sneak_f
xmap F <Plug>Sneak_F
omap f <Plug>Sneak_f
omap F <Plug>Sneak_F

"replace 't' with 1-char Sneak
nmap t <Plug>Sneak_t
nmap T <Plug>Sneak_T
xmap t <Plug>Sneak_t
xmap T <Plug>Sneak_T
omap t <Plug>Sneak_t
omap T <Plug>Sneak_T

nmap <expr> <Tab>   sneak#is_sneaking() ? '<Plug>SneakNext'     : 'za'
nmap <expr> <S-Tab> sneak#is_sneaking() ? '<Plug>SneakPrevious' : 'za'

vmap <expr> <Tab>   sneak#is_sneaking() ? '<Plug>SneakNext'     : '<Tab>'
vmap <expr> <S-Tab> sneak#is_sneaking() ? '<Plug>SneakPrevious' : '<S-Tab>'

let g:sneak#s_next = 1

let g:sneak#prompt = 'Target key: '

function! s:RestoreS()
  " Restore default s/S behavoir
  nunmap s
  nunmap S
endfunction

au VimEnter * :call s:RestoreS()

" vim-move

let g:move_key_modifier = 'C'

" Search word under cursor
nnoremap <leader>/ :F <C-r>=functions#escape_pattern(expand('<cword>'))<CR><Space> **/*.*
vnoremap <leader>/ :<c-u>F <C-r>=functions#escape_pattern(functions#get_visual_selection())<CR><Space> **/*.*

" ----------------------------------------------------------------------
" | CTRLP                                                              |
" ----------------------------------------------------------------------

let g:ctrlp_working_path_mode = 'ra'

if executable("rg")
  let g:ctrlp_user_command = 'rg %s -l --files --color=never -g ""'

  let g:ackprg = 'rg --vimgrep'
  cnoreabbrev ag Ack!

  set grepprg=rg\ --no-heading\ --vimgrep
  set grepformat=%f:%l:%c:%m

  " rg is fast enough that CtrlP doesn't need to cache
  let g:ctrlp_use_caching = 0
elseif executable("ag")
  let g:ctrlp_user_command = 'ag %s -l --nocolor --nogroup --hidden
        \ --ignore .git
        \ --ignore .DS_Store
        \ --ignore .svn
        \ --ignore .hg
        \ --ignore node_modules
        \ --ignore target
        \ --ignore .idea
        \ --ignore bower_components
        \ --ignore logs
        \ --ignore out
        \ -g ""'

  let g:ackprg = 'ag --vimgrep'
  cnoreabbrev rg Ack!

  " Use ag over grep
  set grepprg=ag\ --nogroup\ --nocolor

  " ag is fast enough that CtrlP doesn't need to cache
  let g:ctrlp_use_caching = 0
endif

noremap <leader>b :CtrlPBuffer<CR>

let g:ctrlp_match_window  = 'bottom,order:btt,min:1,max:50,results:50'
let g:ctrlp_mruf_relative = 1
let g:ctrlp_mruf_max      = 10
let g:ctrlp_reuse_window  = 'NERD_tree'
let g:ctrlp_max_files     = 0

let g:ctrlp_cmd = 'call CallCtrlP()'

func! CallCtrlP()
  if exists('s:called_ctrlp')
    CtrlPLastMode
  else
    let s:called_ctrlp = 1
    CtrlPMRU
  endif
endfunc

" ----------------------------------------------------------------------
" | FAR                                                                |
" ----------------------------------------------------------------------

let g:far#auto_preview = 1

if executable("rg")
  if has('nvim')
    let g:far#source = 'rgnvim'
  else
    let g:far#source = 'rg'
  endif
elseif executable("ag")
  if has('nvim')
    let g:far#source = 'agnvim'
  else
    let g:far#source = 'ag'
  endif
endif

" Ctrl-o: Go back in the jumplist, also realign the screen
nnoremap <c-o> <c-o>zzzv

" NeoTerm

if has('nvim')
  let g:neoterm_position   = 'vertical'
  let g:neoterm_shell      = $SHELL
  let g:neoterm_autoinsert = 1

  nnoremap <silent> <leader>tn :Tnew<CR>
  nnoremap <silent> <leader>tt :Ttoggle<CR>
endif

" the /g flag on :s substitutions by default
set gdefault

" ----------------------------------------------------------------------
" Startify
" ----------------------------------------------------------------------

let g:startify_enable_special         = 0
let g:startify_files_number           = 10
let g:startify_relative_path          = 1
let g:startify_change_to_dir          = 0
let g:startify_update_oldfiles        = 1
let g:startify_session_delete_buffers = 0

let g:startify_skiplist = [
      \ 'COMMIT_EDITMSG',
      \ '~/.config/nvim/init.vim'
      \ ]

let g:startify_bookmarks = [
      \ '~/.config/nvim/init.vim'
      \ ]

let g:startify_custom_footer =
      \ ['', "   Vim is charityware. Please read ':help uganda'.", '']

hi StartifyBracket ctermfg=240
hi StartifyFile    ctermfg=147
hi StartifyFooter  ctermfg=240
hi StartifyHeader  ctermfg=114
hi StartifyNumber  ctermfg=215
hi StartifyPath    ctermfg=245
hi StartifySlash   ctermfg=240
hi StartifySpecial ctermfg=240

let g:startify_session_autoload     = 0
let g:startify_session_persistence  = 0

" Vim expand region

map K <Plug>(expand_region_expand)
map J <Plug>(expand_region_shrink)

" Optimize
hi! NonText cterm=NONE ctermfg=NONE

" Typescript

let g:typescript_compiler_binary  = 'tsc'
let g:typescript_compiler_options = ''

let g:typescript_indent_disable = 1

autocmd QuickFixCmdPost [^l]* nested cwindow
autocmd QuickFixCmdPost    l* nested lwindow

autocmd FileType typescript JsPreTmpl html
" autocmd FileType typescript syn clear foldBraces  " For leafgarland/typescript-vim users only. Please see https://github.com/Quramy/vim-js-pretty-template/issues/1 for details.

" Flow

" let g:flow#enable    = 0
" let g:flow#errjmp    = 0
" let g:flow#autoclose = 1

" ----------------------------------------------------------------------------
" :Root | Change directory to the root of the Git repository
" ----------------------------------------------------------------------------
function! s:root()
  let root = systemlist('git rev-parse --show-toplevel')[0]
  if v:shell_error
    echo 'Not in git repo'
  else
    execute 'lcd' root
    echo 'Changed directory to: '.root
  endif
endfunction
command! Root call s:root()

" ----------------------------------------------------------------------------
" HL | Find out syntax group
" ----------------------------------------------------------------------------
function! s:hl()
  " ech  synIDattr(synID(line('.'), col('.'), 0), 'name')
  echo join(map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")'), '/')
endfunction
command! HL call <SID>hl()

" ----------------------------------------------------------------------------
" EX | chmod +x
" ----------------------------------------------------------------------------
command! EX if !empty(expand('%'))
         \|   write
         \|   call system('chmod +x '.expand('%'))
         \|   silent e
         \| else
         \|   echohl WarningMsg
         \|   echo 'Save the file first'
         \|   echohl None
         \| endif

" ----------------------------------------------------------------------------
" Profile
" ----------------------------------------------------------------------------
function! s:profile(bang)
  if a:bang
    profile pause
    noautocmd qall
  else
    profile start /tmp/profile.log
    profile func *
    profile file *
  endif
endfunction
command! -bang Profile call s:profile(<bang>0)

" nnoremap <C-h> <C-w>h
" nnoremap <C-j> <C-w>j
" nnoremap <C-k> <C-w>k
" nnoremap <C-l> <C-w>l

" Terminal mappings
if has('nvim')
  tnoremap <Esc> <C-\><C-n>

  tnoremap <C-w>h <C-\><C-n><C-w><C-h>
  tnoremap <C-w>j <C-\><C-n><C-w><C-j>
  tnoremap <C-w>k <C-\><C-n><C-w><C-k>
  tnoremap <C-w>l <C-\><C-n><C-w><C-l>

  tnoremap <C-w>w <C-\><C-n><C-w><C-w>
endif

"select pasted text
nnoremap <expr> gp '`[' . strpart(getregtype(), 0, 1) . '`]'

"stay same position on insert mode exit
inoremap <silent> <Esc> <Esc>`^

"mixed indent
nnoremap <c-c>i :%retab!<CR>

"trailing
nnoremap <c-c>t :%s/\s\+$//e<cr>:nohl<cr>

" Toggle quickfix list
fun! s:QuickfixToggle()
  let nr = winnr("$")
  copen
  let nr2 = winnr("$")
  if nr == nr2
    cclose
  endif
endfunction
nnoremap <c-c>q :call <SID>QuickfixToggle()<cr>

" Vim-signiture
let g:SignatureMarkTextHLDynamic = 1

" ----------------------------------------------------------------------------
" NERDTree
" ----------------------------------------------------------------------------

let g:NERDTreeMapMenu='M'

let NERDTreeShowLineNumbers=0

" let NERDTreeIgnore=['dist/*', 'out', 'logs', '.DS_Store', '.git', '.idea', '.tags', '\~$']

let NERDTreeShowHidden=1

let NERDTreeRespectWildIgnore=1

" Disable display of '?' text and 'Bookmarks' label.
let g:NERDTreeMinimalUI=1

" The default of 31 is just a little too narrow.
let g:NERDTreeWinSize=40

" Single-click to toggle directory nodes, double-click to open non-directory
" nodes.
let g:NERDTreeMouseMode=2

let NERDTreeHijackNetrw=1


" let g:WebDevIconsUnicodeDecorateFolderNodes = 1
" let g:DevIconsEnableFoldersOpenClose = 1

" the amount of space to use after the glyph character (default ' ')
let g:WebDevIconsNerdTreeAfterGlyphPadding = ''
let g:WebDevIconsNerdTreeGitPluginForceVAlign=0

autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

let g:WebDevIconsOS = 'Darwin'

" let g:NERDTreeDirArrowExpandable = '›'
" let g:NERDTreeDirArrowCollapsible = '⌄'

let g:NERDTreeDirArrowExpandable = '▸'
let g:NERDTreeDirArrowCollapsible = '▾'

let g:NERDTreeGitStatusNodeColorization = 1
let g:NERDTreeGitStatusWithFlags = 0

" let g:NERDTreeFileExtensionHighlightFullName = 1

" Let <Leader><Leader> (^#) return from NERDTree window.
let g:NERDTreeCreatePrefix='silent keepalt keepjumps'

let g:webdevicons_conceal_nerdtree_brackets = 1

let g:webdevicons_enable_nerdtree = 1

" Tweaks for browsing
let g:netrw_banner = 0
let g:netrw_browse_splits = 4
let g:netrw_altv = 1
let g:netrw_liststyle = 3
let g:netrw_list_hide = netrw_gitignore#Hide()
let g:netrw_list_hide .= ',\(^\|\s\s\)\zs\.\S\+'

nnoremap <silent> <c-n>e :Explore<cr>

if has('autocmd')
  augroup AmsaykNERDTree
    autocmd!
    autocmd User NERDTreeInit call functions#attempt_select_last_file()
  augroup END
endif

" Stylefmt
nnoremap <silent> <c-c>f :Stylefmt<CR>
vnoremap <silent> <c-c>f :StylefmtVisual<CR>

" Sort motion
let g:sort_motion_flags = "u"

" ----------------------------------------------------------------------
"  Local Settings                                                     |
" ----------------------------------------------------------------------

" Load local settings if they exist.
"
" [!] The following needs to remain at the end of this file in
"     order to allow any of the above settings to be overwritten
"     by the local ones.

if filereadable(glob('~/.vimrc.local'))
  source ~/.vimrc.local
endif

